module.exports = "precision highp float;\n// original - http://glslsandbox.com/e#61886.0\nuniform float time;\nuniform vec2 res;\nuniform float rot;\nuniform float color;\nuniform float alpha;\nuniform float bg;\nuniform float zMove;\n#define fTime time*0.2\n#define resolution res\n#define iterations 4\n#define formuparam2 .9\n#define volsteps 4\n#define stepsize .1\n#define zoom 4.\n#define tile   0.45\n#define speed2  1.0\n#define brightness 0.1\n#define darkmatter 0.6\n#define distfading 0.8\n#define saturation 0.9\n#define transverseSpeed .0\n#define cloud 0.1\n#define fieldIterations 7\nfloat triangle(float x, float a)\n{\nfloat output2 = 2.0*abs(  2.0*  ( (x/a) - floor( (x/a) + 0.5) ) ) - 1.0;\nreturn output2;\n}\nfloat field(in vec3 p) {\n\tfloat strength = 8. + .03 * log(1.e-6 + fract(sin(fTime) * 4373.11));\n\tfloat accum = 0.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < fieldIterations; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.8 + 0.1*sin(fTime*0.2 + 2.0), -1.1+0.3*cos(fTime*0.15));\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.3));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\nvoid main()\n{\n    vec2 vUv =  gl_FragCoord.xy / resolution;\n    vec2 uv2 = vUv*2.-1.;\n\tvec2 uvs = uv2 * resolution.xy / max(resolution.x, resolution.y);\n\tfloat fTime2 = fTime*0.7;\n    float speed = speed2;\n\tspeed = 0.1;\n    float formuparam = formuparam2;\n    vec3 colors[2];\n    float revColor = 1. -color*0.5;\n    colors[0] = vec3(vUv.x * (2. * revColor),vUv.y,1.)*0.4 * revColor + 0.05*color ;\n    colors[1] = vec3(vUv.x * (2. * revColor),vUv.y,1.)*0.4 * revColor + 0.05*color ;\n\tvec2 uv = uvs;\n\tfloat a_xz = 0.9;\n\tfloat a_yz = -.6;\n\tfloat a_xy = 0.9 + fTime*0.04;\n\tmat2 rot_xz = mat2(cos(a_xz),sin(a_xz),-sin(a_xz),cos(a_xz));\n\tmat2 rot_yz = mat2(cos(a_yz),sin(a_yz),-sin(a_yz),cos(a_yz));\n\tmat2 rot_xy = mat2(cos(a_xy),sin(a_xy),-sin(a_xy),cos(a_xy));\n\tfloat v2 =1.0;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tvec3 from=vec3(0.0, rot,0.0);\n\tvec3 forward = vec3(0.,0.,1.);\n\tfrom.x += transverseSpeed*(1.0)*cos(0.01*fTime) + 0.001*fTime;\n\tfrom.y += transverseSpeed*(1.0)*sin(0.01*fTime) +0.001*fTime;\n\tdir.xy*=rot_xy;\n\tforward.xy *= rot_xy;\n\tdir.xz*=rot_xz;\n\tforward.xz *= rot_xz;\n\tdir.yz*= rot_yz;\n\tforward.yz *= rot_yz;\n\tfrom.xy*=-rot_xy;\n\tfrom.xz*=rot_xz;\n\tfrom.yz*= rot_yz;\n\tfloat zooom = zMove;\n\tfrom += forward* zooom;\n\tfloat sampleShift = mod( zooom, stepsize );\n\tfloat zoffset = -sampleShift;\n\tsampleShift /= stepsize;\n\tfloat s=0.24;\n\tfloat s3 = s + stepsize/2.0;\n\tvec3 v=vec3(0.);\n\tfloat t3 = 0.0;\n\tvec3 backCol2 = vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p2=from+(s+zoffset)*dir;\n\t\tvec3 p3=(from+(s3+zoffset)*dir )* (1.9/zoom);\n\t\tp2 = abs(vec3(tile)-mod(p2,vec3(tile*3.5)));\n\t\tp3 = abs(vec3(tile)-mod(p3,vec3(tile*2.)));\n\t\t#ifdef cloud\n\t\tt3 = field(p3);\n\t\t#endif\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) {\n\t\t\tp2=abs(p2)/dot(p2,p2)-formuparam;\n\t\t\tfloat D = abs(length(p2)-pa);\n\t\t\tif (i > 2)\n\t\t\t{\n\t\t\ta += i > 7 ? min( 12., D) : D;\n\t\t\t}\n\t\t\t\tpa=length(p2);\n\t\t}\n\t\ta*=a*a;\n\t\tfloat s1 = s+zoffset;\n        float d = pow(distfading,max(0.,float(r)-sampleShift));\n\t\tfloat fade = d;\n        float cv = float(r) + zoffset ;\n\t\tif( r == 0 ){\n\t\t\tfade *= (1. - (sampleShift));\n            cv += 6.;\n        }\n\t\tif( r == volsteps-1 ) fade *= sampleShift;\n        float mixVal = sin(1. / float(volsteps) * float(r) * 6.28) *0.5 +0.5;\n        vec3 color = mix(colors[0], colors[1], sin(mixVal*6.28) *0.5 + 0.5 );\n\t\tbackCol2 += mix(.4, 1., v2) * vec3(color.r * t3 * t3,  color.g * t3 * t3 ,  t3 * color.b *t3) * fade;\n\t\ts += stepsize;\n\t\ts3 += stepsize;\n    }\n\tv = mix( vec3( length(v)), v, saturation );\n\tvec4 forCol2 = vec4(v*.01,1.);\n\t#ifdef cloud\n\tbackCol2 *= cloud;\n\t#endif\n    vec4 purple = vec4(0.25,0.00,0.48,1.) * bg * (0.2 + (1.-vUv.y) *0.6);\n\tgl_FragColor = (forCol2 + vec4(backCol2, 1.0) + purple) * alpha;\n}\n"